## 一 存储用户信息

#### 1.1 存储规则

```
hset login token uid                # 创建login哈希，并设置某个token的值为uid
hget login token                    # 获取某个token是哪个用户
zadd recent token timestamp         # 记录最后一次浏览时间
zadd viewed token item timestamp    # 记录用户浏览过的记录
zremrangebyrank viewd token 0 26    # 移除旧的浏览记录，只保留最近25个
```

也需要对token数进行定期检查，以防止令牌数超过限制：
```
zcard recent                        # 获取当前令牌数
zrange recent 0 end                 # 计算出需要移除的令牌数，并获取它们对应的token

# 清理函数：移除旧令牌
delete keys                         # 移除最近浏览记录：keys为 viewed与token对应的数组
hdel login tokens                   # 移除旧令牌登录信息
zrem recent tokens                  # 移除旧令牌最近一次浏览信息
```

在该案例中，如果移除旧令牌的程序在执行时，用户正好登录了，那么会造成该用户的登录信息被删除，用户需要再次登录。这里产生了竞态条件。

## 二 购物车

#### 2.1 购物车规则

每个用户的购物车都是一个散列HASH，这个散列存储了商品ID和商品订购数的映射。对商品数量的验证由web程序本身处理，redis这里要处理的是：
- 商品订购数量出现变化时，更新购物车
- 如果用户订购某件商品数大于0，则存储商品ID与该用户订购数添加到散列，已经存在则新的订购数将覆盖
- 如果订购数<=0则从散列中移除

```
hset cart session item count
hrem cart session item
```

此时案例一种的清理函数可以添加上cart相关的需要清理数据。

## 三 网页缓存

#### 2.1 网页缓存规则

网页中包括一些静态内容如html、css、js也包含一些动态生成的数据，大多数网站每天只会改变一次，即动态内容其实并不需要动态生成。减少动态生成内容的时间可以降低网站负载，加快载入。  

我们可在处理请求之前加入中间件，调用redis缓存函数：对于一个不能被缓存的页面请求直接返回，可以被缓存的请求，函数首先从缓存里面取出并返回被缓存的页面，如果缓存页面不存在，那么函数生成页面将其缓存在redis里5分钟，最后再将页面返回给调用者。