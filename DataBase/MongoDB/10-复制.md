## 一 复制的简介
#### 1.1 复制的作用
Mongo支持在多台机器中通过异步复制达到故障转移和冗余数据备份，多台机器中只有一台用于写。  

为什么要复制：
- 数据备份
- 数据灾难恢复
- 读写分离
- 高（24* 7）数据可用性
- 无宕机维护
- 副本集对应用程序是透明
#### 1.2 复制的原理
主从复制是MongoDB最常用的复制方式，至少需要两个节点A、B，A是主节点，负责处理客户端请求,其余的都是从节点，负责复制主节点上的数据。  
节点常见的搭配方式为：一主一从、一主多从。主节点记录在其上的所有操作，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。  
但是要额外注意：3.2版后已移除主从复制，复制集已经在大多数场合下替代了 master-slave 复制。  
复制集就是有自动故障恢复的功能，主从集群和复制集群最明显的区别是复制集没有固定的主节点，整个集群会选举出一个主节点。  
复制集所有的东西都是自动化的：自动提升备份节点为活跃节点，以确保正常工作，只需要为复制集指定一下服务器，驱动程序就会自动找到服务器
## 二 复制集操作
接下来的操作需要打开多个终端窗口，而且可能会连接多台linux主机，
```
step1:使用如下格式启动mongod，注意replSet（属于哪个复制集）的名称是一致的
mongod --port 27017 --dbpath ~/Desktop/t1 --logpath ~/Desktop/t1log --replSet rs0            
mongod --port 27018 --dbpath ~/Desktop/t2 --logpath ~/Desktop/t1log --replSet rs0

step2:连接其中任意服务器
mongo --host 192.168.196.128 --port 27017
rs.initiate()               # 初始化，然后查看当前状态
rs.status()

step3:添加复本集，这个操作也可以可以在initiate中传入一个json配置            
rs.add('192.168.196.128:27018')
rs.status()
传入json配置的方式：
var conf = {
    _id:"rs0",
    memebers:[
        {_id:0,host:192.168.196.128:27018},     # id为0的默认为primary
        {_id:1,host:*****}
    ]
}
rs.initiate(conf)

step4:连接第二个mongo服务
mongo --host 192.168.196.128 --port 27018
执行插入数据
use test1
for(i=0;i<10;i++){db.t1.insert({_id:i})}
db.t1.find()

step5:在从服务器中插查询 如果在从服务器上进行读操作，需要设置rs.slaveOk()
rs.slaveOk()
db.t1.find()

删除从节点
rs.remove('192.168.196.128:27018')
关闭主服务器后，再重新启动，会发现原来的从服务器变为了从服务器，新启动的服务器（原来的从服务器）变为了从服务器
```