## 一 索引简介
索引可以提高查询速度，但是会降低写入速度。在Mongo中索引可以按字段升序或者降序创建，便于排序，索引默认使用btree组织索引文件，当然也允许使用hash索引。  
```
//explain可以输出查询信息  uindex是user文档的一个字段，从1开始到10000依次递增
db.user.find({"uindex":100}).explain()     
这时候会输出：
{
    "cursor":"BasicCursor",
    "nscanedObjects":100
    ...
}
```
BasicCursor代表没有使用索引，nscanedObjects代表扫描了多少次。在没有使用索引时，按照`{"name":"lisi"}`要求依次查找，直到查找到要求的结果。  
添加索引后查询：
```
db.user.ensureIndex({uindex:1})     
db.user.find({"uindex":100}).explain() 
此时输出的结果是：
{
    "cursor":"BtreeCursor uindex",
    "nscanedObjects":1
    ...
}
```
## 二 索引的增删查
```
# 查看索引
db.user.getIndexes()            //_id是默认索引

# 创建索引   1代表正向 -1代表反向（在磁盘上倒序）
db.user.ensureIndex({name: -1}) 


# 删除索引  需要带上类型
db.user.dropIndex({name: -1})
db.user.dropIndexes()           //删除所有非_id索引
```

多列索引：
```
# 同时为name，uindex建立索引,这有别于分别为name，uindex各添加索引
# 多列索引的意义在于将name和uindex绑定到了一起，适用于查询时候经常同时查询name和uindex
db.user.ensureIndex({name:1,uindex:-1})     
```

子文档索引
```
# 有这样的复杂文档
{name:"zs",info:{age:16, from:"北京"}}
{name:"lisi",info:{age:22, from:"上海"}}

# 需求，查询来自北京的 db.user.find(info:{from:"北京"})是无法查到的
db.user.ensureIndex({info.from: 1})
```
## 三 索引的分类
上述创建的索引都是普通索引，在创建索引时候可以指定一些参数：
```
# 创建唯一索引  索引值不能重复，即下列的uindex值不能重复
db.user.ensureIndex({uindex: 1},{unique:true}) 

# 创建稀疏索引  
# 如果一个文档内被索引的字段不存在（值为null），仍然会建立索引
# 创建稀疏索引，则遇到上述情况后，不会建立索引
db.user.ensureIndex({uindex: 1},{sparse:true})

# 创建哈希索引  
# 哈希有一个内部函数，存储数据时候使用该函数创建位置，比btree（基于二叉树）更快的找到数据，但是hash计算的位置具有散列的特性，所以如果按照范围查找会受到影响（因为会在硬盘上随机查找）
db.user.ensureIndex({uindex: "hashed"})
```
## 四 索引重建
一个表经过多次修改后，会导致表的文件产生空洞，索引文件也是如此，可以通过重建所有索引来减少索引碎片，提升索引效率。
```
db.user.reIndex()
```