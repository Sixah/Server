## 一  事务概念

当一个业务逻辑需要多个sql完成时，如果其中某条sql语句出错，则希望整个操作都退回，使用事务可以完成退回的功能，保证业务逻辑的正确性。比如银行的转账，任意一个步骤出错，就应该全部停止回滚。  

事务四大特性(简称ACID)：
- 原子性(Atomicity)：		事务的全部操要么全部完成，要么均不执行；
- 一致性(Consistency)：	    并行执行的多个事务，执行结果必须与串行执行结果一致；
- 隔离性(Isolation)：		事务的执行不受其他事务的干扰，但中间结果对其他事务透明的
- 持久性(Durability)：		已提交事务，系统必须保证该事务对数据库的改变不被丢失。

注意：
- 表必须是innodb或bdb类型，才可以对此表使用事务 
- inndb原理：对当前操作的行加锁；适合插入增删改（写入速度快），其他引擎常见的是对整张表加锁，查询速度很快。

## 二 事务使用

#### 2.1 自动提交

在mysql中事务默认自动提交，通过语句查看是否自动提交：
```
show variables like ‘%commit%’;
set autocommit=off;	                    # 该语句可以关闭自动提交，但是要注意，关闭后所有的事务都需要手动提交
```

如果需要明确通过commit，rollback来提交事务和回滚事务，那么需要使用事务控制命令来开始事务。事务常用命令：`begin  commit  rollback`

事务示例：
```
终端1：                                     终端2：
----------------------------------------------------------------------------------------------

步骤1：打开两个终端，连接mysql，使用同一个数据库，操作同一张表
select * from users;                        begin;      # 或者 start transaction
                                            insert into users(name) values('张飞');
----------------------------------------------------------------------------------------------

步骤2：终端1查询结果（查不到）
select * from users;
----------------------------------------------------------------------------------------------

步骤3:终端2提交
                                            commit;
----------------------------------------------------------------------------------------------

步骤4：终端1再次查询
select * from users;
---------------------------------------------------------------------------
```

#### 2.1 commit与 commit and chain

- commit：提交后，别的线程可以查看到提交的结果
- commit and chain：提交后再开启一个新的事务，别的线程无法查看到刚才提交的结果

#### 2.2 save point

在事务中可以通过定义savepoint，指定回滚事务的一个部分，但是不能指定提交事务的一个部分，

使用方式：
```
# 在事务中：
save point test;            # 设置一个回滚点 test
rollback to savepoint test; 
```

## 三 隔离级别

#### 3.0 事务的安全隐患

事务会产生三种问题（尤其是并发场合）：
- 脏读：一个事务读取到了另外一个事务未提交数据
- 虚读：即不可重复读，在同一个事务中，两次读取到的数据不一样
- 幻读：一个事务操作数据表中所有记录，另一个事务添加了一个数据，则前者查询不到自己的修改

为了解决上述问题，SQL标准定义了4种隔离级别，指定了事务中哪些数据改变其他事务可见，哪些数据改变其他事务不可见。  

低级别的隔离级别可以支持更高的并处理，同时占用的系统资源更少。

```
# 查看隔离级别：	
select @@tx_isolation

# 设置隔离级别：	
set session transaction isolation level 

# 隔离级别名:session也可以改为global，即全局的隔离级别
```

4个隔离级别：		
- read uncommitted：读未提交，会产生脏读 不可重复读 幻读
- read committter：读已提交，会产生不可重复度 幻读。Oracle默认隔离级别。
- reapeatable read：可重复度，会产生幻读。MySQL默认隔离级别
- serializebale：串行化，可所有问题

#### 3.1 读未提交--脏读

某个事务已经更新了一个数据，但是另一个事务在此时读取了一份数据，前一个事务回滚，后一个事务就会读取到不存在的数据。  

该事物隔离级别低，且响应提升性能空间少，所以用的较少。   


#### 3.2 读已提交--不可重复读

提交读是大多数数据库默认的隔离级别，但是不是mysql的默认级别。该级别是人们比较常能理解的：一个事务在开始到提交前所做的任何改变都是不可见的，只能等待提交后才能看到。  

在MySQL中，开启A事务和B事务，B事务提交后，A事务能够读取到更新的数据。  

虽然这个隔离级别屏蔽了脏读，但是这样会造成不可重复读：一个事务读取到了另外一个事务提交的数据，造成前后两次查询结果不一致。  

#### 3.3 可重复读--幻读

MySQL默认隔离级别：确保同一事务的不同实例在并发读取数据时，会看到相同的数据行。  

但是会出现幻读：一个事务读到了另一个事务insert的数据，造成前后查询结果不一致。  

第1个事务实例对表中的所有数据进行了修改；  
第2个事务实例向表中插入一行；  
以后会发生操作第1个事务的用户发现表中存在没有被修改的行。  

#### 3.4 可串行化

在每个读的数据上加共享锁，强制事务排序，避免幻读，但是会导致大量的超时、锁竞争现象，一般不推荐使用。

#### 3.5 演示脏读

演示脏读（也包含不可重复度，因为窗口B在同一事务中查询到了不同的结果）：
```
# 假设uid1和uid2的账户都是1000元
# 窗口A # 窗口B
set global transaction read uncommitted; select * from account; # 得到二者都是1000元
start transaction; start transaction;
-- 转账操作 -- 
update accoutn set balance=balance-500 where uid=1;
update accoutn set balance=balance+500 where uid=2; 
select * from account; # uid1为500，uid2为1500，读取了未提交的数据
roolback;
# 两边此时拿到的数据已经不一样了
```

提升一档事务的隔离级别，重复上述操作，窗口B查询到的结果永远都是1000，不会读取到窗口A的事务，避免了脏读。但是当窗口A提交后，窗口B的事务还是读取到了另外一个事务的数据，即不可重复度的现象还在。此时可以继续提升事务的隔离级别。 