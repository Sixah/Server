## 四 锁的初步认识

#### 4.1 丢失更新与锁

第二个事务的update覆盖了第一个事务的update，这样就造成了丢失更新，锁可以用来解决丢失更新问题。  

我们可以将锁的策略分为：
- 悲观锁
- 乐观锁

锁在本质上其实是：保证某个线程对资源进行独占！

#### 4.2 悲观锁

查询的时，认为一定会出现丢失更新，那么 查询语句后 加入 for update（排他锁）
![](/images/sql/beiguansuo.png)

#### 4.3 乐观锁

乐观锁：要求程序员自己控制，额外添加一个字段，比如版本 version:0  

第二个事务如果发现版本不一样，则重新查。 

![](/images/sql/leguansuo.png)


![](/images/sql/mysql-suo01.png)




## 五 锁进阶

#### 5.1 锁的概念

锁的分类：
- 表级锁：MyISAM和MEMORY引擎支持。
- 页级锁：BDB引擎支持。
- 行级锁：InnoDB引擎支持。

默认情况下，表锁和行锁都是自动获得的，不需要额外命令。但是有些情况下，开发者也需要明确进行锁表和事务控制。


#### 5.2 locak table

```
# 锁表:锁定用于当前线程的表，如果该表被其他线程锁定，则当前线程会等待，直到可以获取锁
locak tables user;

# 解锁:用于释放当前线程获取的任何锁。当然，服务器连接关闭时，当前线程锁定的表也会被隐式解锁
unlock tables;
```